package aqs;

/**
 * @Author: 秒度
 * @Email: fangxin.md@Gmail.com
 * @Date: 2020-12-23 22:54
 * @Description:
 */

public class AbstractQueuedSynchronizertTxt {
    //是用来构建锁或者其它同步器组件的重量级基础框架及整个JUC体系的基石， 通过内置的FIFO队列来完成资源获取线程的排队工作，并通过一个int类变量表示持有锁的状态


    //有阻塞就需要排队，实现排队必然需要有某种形式的队列来进行管理

    //抢到资源的线程直接使用办理业务，抢占不到资源的线程的必然涉及一种排队等候机制，抢占资源失败的线程继续去等待(类似办理窗口都满了，暂时没有受理窗口的顾客只能去候客区排队等候)，
    // 仍然保留获取锁的可能且获取锁流程仍在继续(候客区的顾客也在等着叫号，轮到了再去受理窗口办理业务）。
    //既然说到了排队等候机制，那么就一定 会有某种队列形成，这样的队列是什么数据结构呢?
    //如果共享资源被占用，就需要一定的阻 塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中，这个队列就是AQS的抽象表现。
    // 它将请求共享资源的线程封装成队列的结点(Node) ，通过CAS、自旋以及LockSuport.park()的方式，维护state变量的状态，使并发达到同步的效果。

    //TODO
    //CLH:Craig、Landin and Hagersten队列  是一个单向链表，AQS中得到队列是CLH变体的虚拟双向队列FIFO

    //可以明显看出公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件:
    //hasQueuedPredecessors()
    //hasQueuedPredecessors是公平锁加锁时判断等待队列中是否存在有效节点的方法
}
